{"version":3,"file":"gauge.min.js","sources":["../src/gauge.js"],"sourcesContent":["import Templates from 'core/templates';\nimport Widget from 'lytix_helper/widget';\nimport {makeLoggingFunction} from 'lytix_logs/logs';\n\nconst\n    GAP_FACTOR = 0.333,\n    GAP_SIZE = Math.PI * 2 * GAP_FACTOR, // Radians\n    GAP_OFFSET = GAP_SIZE / 2,\n    MAX_ARC = Math.PI * 2 - GAP_SIZE,\n    STROKE_WIDTH = 5,\n    NEEDLE_LENGTH = 28;\n\nconst\n    viewBox = {\n        min: -50,\n        length: 100,\n        height: 95,\n    },\n    view = {\n        viewBox: viewBox,\n        arcs: new Array(3),\n        strokeWidth: STROKE_WIDTH * 1.01, // Increase slightly to avoid slight gaps\n        captions: new Array(3),\n        labels: [\n            /* {\n                x: 0,\n                y: 0,\n                number: 0,\n                align: 'left',\n            } */\n        ],\n    };\n\nlet radius = (viewBox.length - STROKE_WIDTH) / 2; // Reduced by stroke width on each iteration\n\n/**\n * Converts an angle to the cartesian coordinates (x, y) on a given circle.\n * The center is (0, 0).\n * With help from: https://stackoverflow.com/a/18473154\n *\n * @param {Number} radius The radius of the circle.\n * @param {Number} angle The angle in radians.\n * @return {Object} An object with x and y properties.\n */\nconst polarToCartesian = (radius, angle) => {\n    return {\n        x: radius * Math.cos(angle),\n        y: radius * Math.sin(angle),\n    };\n};\n\n/**\n * Calculates the necessary data to draw one segment of an SVG arc using the globally set ‘radius’.\n *\n * @param {Number} startAngle The segment starts here.\n * @param {Number} endAngle The segment ends here.\n * @return {Object} Contains data for the inner and outer Arcs to be drawn as <path>.\n */\nconst calculateSvgArc = (startAngle, endAngle) => {\n    return {\n         radius: radius,\n         start: polarToCartesian(radius, startAngle),\n         end: polarToCartesian(radius, endAngle),\n    };\n};\n\n/**\n * Get data needed for partially drawing the outline of an arc.\n *\n * @param {Number} radius The radius of the arc.\n * @param {Number} fraction The score to be rendered as fraction (50 % → 0.5).\n * @return {Object} Contains the values for ‘stroke-dasharray’ and ‘stroke-dashoffset’.\n */\nconst calculateDashData = (radius, fraction) => {\n    const fullLength = radius * 2 * Math.PI * (1 - GAP_FACTOR);\n    return {\n        fullLength: fullLength,\n        length: fullLength * (1 - fraction),\n    };\n};\n\n\nexport const init = (contextid, courseid, userid, isteacher) => {\n    const log = makeLoggingFunction(userid, courseid, contextid, 'measure');\n\n    const stringsPromise = Widget.getStrings({\n        lytix_measure: { // eslint-disable-line camelcase\n            identical: [\n                'hello',\n                'personal_dashboard',\n                'unlocked_activities',\n                'total_students',\n                'number_previous_activities',\n                'number_open_activities',\n                'mine',\n                'lowest',\n                'highest',\n                'avg',\n                'total',\n                'summary',\n            ],\n        },\n    });\n    const dataPromise = Widget.getData(\n        'local_lytix_lytix_measure_measure_get',\n        {contextid: contextid, courseid: courseid, userid: userid}\n    )\n    .then(data => {\n        const\n            scores = data.Scores,\n            // Is being reused for strings\n            keys = scores.keys = [\n                'Highest',\n                'Avg',\n                isteacher ? 'Lowest' : 'Mine'\n            ];\n\n        const fractions = scores.fractions = new Array(scores.Activity.length);\n        scores.currentFractions = null;\n\n        // To be called when a category in the filter is checked\n        scores.updateActivityFractions = index => {\n            if (!fractions[index]) {\n                fractions[index] = new Array(3);\n                const max = scores.Max[index];\n                for (let i = 0; i < 3; ++i) {\n                    fractions[index][i] = scores[keys[i]][index] / max;\n                }\n            }\n            scores.currentFractions = fractions[index];\n        };\n\n        // Set the current fractions to ‘total’\n        scores.updateActivityFractions(0);\n\n        return data;\n    });\n\n    Promise.all([stringsPromise, dataPromise])\n    .then(values => {\n        const\n            strings = view.strings = values[0],\n            data = values[1],\n            scores = data.Scores,\n            currentFractions = scores.currentFractions;\n\n        view.isteacher = isteacher;\n\n        if (isteacher) {\n            view.StudentCount = data.StudentCount;\n            view.ActivityCount = data.ActivityCount;\n        } else {\n            view.name = data.Name;\n        }\n\n        view.total = strings.total;\n\n        // Draw arcs\n        const START_ANGLE = Math.PI / 2 + GAP_OFFSET;\n        for (let i = 0; i < 3; ++i) {\n            const\n                score = currentFractions[i],\n                endAngle = START_ANGLE + MAX_ARC;\n            const arcData = view.arcs[i] = calculateSvgArc(START_ANGLE, endAngle);\n            arcData.dash = calculateDashData(radius, score);\n            radius -= STROKE_WIDTH;\n        }\n\n        // Caption (percentages as text)\n        const startCoordinates = polarToCartesian(radius, START_ANGLE);\n        for (let i = 2; i >= 0; --i) {\n            view.captions[2 - i] = {\n                text: strings[scores.keys[i].toLowerCase()],\n                value: Math.round(currentFractions[i] * 100),\n                yShift: 0.5 + 2 - i,\n                xShift: -(2 - i),\n                x: startCoordinates.x,\n                y: startCoordinates.y,\n            };\n        }\n\n        // Draw the placeholder\n        radius = (viewBox.length - STROKE_WIDTH) / 2 - STROKE_WIDTH;\n        view.base = calculateSvgArc(START_ANGLE, START_ANGLE + MAX_ARC);\n        view.base.strokeWidth = STROKE_WIDTH * 3;\n\n        // TODO: draw inner labels (ticks and percentages)\n\n        const\n            fullDegree = 360 * (1 - GAP_FACTOR),\n            needleIndex = isteacher ? 1 : 2;\n\n        // Draw needle\n        {\n            const point = polarToCartesian(NEEDLE_LENGTH, START_ANGLE);\n            view.needle = {\n                r: 5,\n                x: point.x,\n                y: point.y,\n                angle: fullDegree * currentFractions[needleIndex],\n            };\n        }\n\n        // Filter\n        {\n            // Here we have to skip the first entry as it represents the total.\n            const\n                activities = scores.Activity,\n                count = activities.length - 1;\n            view.filter = new Array(count);\n            for (let i = 0; i < count; ++i) {\n                view.filter[i] = {\n                    label: activities[i + 1], // XXX these are category names, no strings available\n                    activityIndex: i + 1,\n                };\n            }\n        }\n\n        return Templates.render('lytix_measure/gauge', view)\n        .then(html => {\n            const container = document.getElementById('gauge');\n            container.innerHTML = html;\n\n            const gauge = container.querySelector('svg');\n            new ResizeObserver(() => {\n                // TODO: reduce calls with setTimeout()\n                const rect = gauge.getBoundingClientRect();\n                // Size adaptation would be better if interpolated, but this suffices.\n                let factor = 1;\n                if (rect.width < 270) {\n                    factor = 0.6;\n                } else if (rect.width < 280) {\n                    factor = 0.7;\n                } else if (rect.width < 370) {\n                    factor = 0.9;\n                }\n                // Cannot use ‘entries’ because they do not provide the right dimensions.\n                gauge.style.fontSize = viewBox.length / rect.height * factor + 'rem';\n            }).observe(container);\n\n            const\n                needle = container.querySelector('.needle line'),\n                arcElements = container.querySelectorAll('.arcs path'),\n                captions = container.querySelectorAll('.caption .value');\n            document.getElementById('gauge-filter').addEventListener('change', (event) => {\n                const activityIndex = event.target.dataset.activityindex;\n\n                scores.updateActivityFractions(activityIndex);\n                log('FILTER', 'ON', scores.Activity[activityIndex]);\n\n                for (let i = 0; i < 3; ++i) {\n                    const\n                        arcElement = arcElements[i],\n                        arcData = view.arcs[i],\n                        fraction = scores.currentFractions[i],\n                        length = arcData.dash.fullLength * (1 - fraction);\n                    arcElement.setAttribute('stroke-dashoffset', length);\n                    captions[2 - i].innerHTML = Math.round(fraction * 100);\n                }\n                const needleAngle = fullDegree * scores.currentFractions[needleIndex];\n                needle.setAttribute('transform', 'rotate(' + needleAngle + ')');\n            });\n\n            return;\n        });\n    })\n    .catch(err => window.console.debug(err));\n};\n"],"names":["GAP_SIZE","Math","PI","GAP_OFFSET","MAX_ARC","viewBox","min","length","height","view","arcs","Array","strokeWidth","STROKE_WIDTH","captions","labels","radius","polarToCartesian","angle","x","cos","y","sin","calculateSvgArc","startAngle","endAngle","start","end","calculateDashData","fraction","fullLength","contextid","courseid","userid","isteacher","log","stringsPromise","Widget","getStrings","lytix_measure","identical","dataPromise","getData","then","data","scores","Scores","keys","fractions","Activity","currentFractions","updateActivityFractions","index","max","Max","i","Promise","all","values","strings","StudentCount","ActivityCount","name","Name","total","START_ANGLE","score","dash","startCoordinates","text","toLowerCase","value","round","yShift","xShift","base","needleIndex","point","needle","r","activities","count","filter","label","activityIndex","Templates","render","html","container","document","getElementById","innerHTML","gauge","querySelector","ResizeObserver","rect","getBoundingClientRect","factor","width","style","fontSize","observe","arcElements","querySelectorAll","addEventListener","event","target","dataset","activityindex","arcElement","arcData","setAttribute","needleAngle","catch","err","window","console","debug"],"mappings":"wYAMIA,SAAqB,EAAVC,KAAKC,GADH,KAEbC,WAAaH,SAAW,EACxBI,QAAoB,EAAVH,KAAKC,GAASF,SAKxBK,QAAU,CACNC,KAAM,GACNC,OAAQ,IACRC,OAAQ,IAEZC,KAAO,CACHJ,QAASA,QACTK,KAAM,IAAIC,MAAM,GAChBC,YAAaC,KACbC,SAAU,IAAIH,MAAM,GACpBI,OAAQ,IAUZC,QAAUX,QAAQE,OAxBH,GAwB4B,EAWzCU,iBAAmB,SAACD,OAAQE,aACvB,CACHC,EAAGH,OAASf,KAAKmB,IAAIF,OACrBG,EAAGL,OAASf,KAAKqB,IAAIJ,SAWvBK,gBAAkB,SAACC,WAAYC,gBAC1B,CACFT,OAAQA,OACRU,MAAOT,iBAAiBD,OAAQQ,YAChCG,IAAKV,iBAAiBD,OAAQS,YAWjCG,kBAAoB,SAACZ,OAAQa,cACzBC,WAAsB,EAATd,OAAaf,KAAKC,cAC9B,CACH4B,WAAYA,WACZvB,OAAQuB,YAAc,EAAID,0BAKd,SAACE,UAAWC,SAAUC,OAAQC,eACxCC,KAAM,6BAAoBF,OAAQD,SAAUD,UAAW,WAEvDK,eAAiBC,gBAAOC,WAAW,CACrCC,cAAe,CACXC,UAAW,CACP,QACA,qBACA,sBACA,iBACA,6BACA,yBACA,OACA,SACA,UACA,MACA,QACA,cAINC,YAAcJ,gBAAOK,QACvB,wCACA,CAACX,UAAWA,UAAWC,SAAUA,SAAUC,OAAQA,SAEtDU,MAAK,SAAAC,UAEEC,OAASD,KAAKE,OAEdC,KAAOF,OAAOE,KAAO,CACjB,UACA,MACAb,UAAY,SAAW,QAGzBc,UAAYH,OAAOG,UAAY,IAAIrC,MAAMkC,OAAOI,SAAS1C,eAC/DsC,OAAOK,iBAAmB,KAG1BL,OAAOM,wBAA0B,SAAAC,WACxBJ,UAAUI,OAAQ,CACnBJ,UAAUI,OAAS,IAAIzC,MAAM,WACvB0C,IAAMR,OAAOS,IAAIF,OACdG,EAAI,EAAGA,EAAI,IAAKA,EACrBP,UAAUI,OAAOG,GAAKV,OAAOE,KAAKQ,IAAIH,OAASC,IAGvDR,OAAOK,iBAAmBF,UAAUI,QAIxCP,OAAOM,wBAAwB,GAExBP,QAGXY,QAAQC,IAAI,CAACrB,eAAgBK,cAC5BE,MAAK,SAAAe,YAEEC,QAAUlD,KAAKkD,QAAUD,OAAO,GAChCd,KAAOc,OAAO,GACdb,OAASD,KAAKE,OACdI,iBAAmBL,OAAOK,iBAE9BzC,KAAKyB,UAAYA,UAEbA,WACAzB,KAAKmD,aAAehB,KAAKgB,aACzBnD,KAAKoD,cAAgBjB,KAAKiB,eAE1BpD,KAAKqD,KAAOlB,KAAKmB,KAGrBtD,KAAKuD,MAAQL,QAAQK,cAGfC,YAAchE,KAAKC,GAAK,EAAIC,WACzBoD,EAAI,EAAGA,EAAI,IAAKA,EAAG,KAEpBW,MAAQhB,iBAAiBK,GACzB9B,SAAWwC,YAAc7D,SACbK,KAAKC,KAAK6C,GAAKhC,gBAAgB0C,YAAaxC,WACpD0C,KAAOvC,kBAAkBZ,OAAQkD,OACzClD,QA5JO,UAgKLoD,iBAAmBnD,iBAAiBD,OAAQiD,aACzCV,GAAI,EAAGA,IAAK,IAAKA,GACtB9C,KAAKK,SAAS,EAAIyC,IAAK,CACnBc,KAAMV,QAAQd,OAAOE,KAAKQ,IAAGe,eAC7BC,MAAOtE,KAAKuE,MAA4B,IAAtBtB,iBAAiBK,KACnCkB,OAAQ,IAAUlB,GAClBmB,SAAU,EAAInB,IACdpC,EAAGiD,iBAAiBjD,EACpBE,EAAG+C,iBAAiB/C,GAK5BL,QAAUX,QAAQE,OA7KP,GA6KgC,EA7KhC,EA8KXE,KAAKkE,KAAOpD,gBAAgB0C,YAAaA,YAAc7D,SACvDK,KAAKkE,KAAK/D,YAAcC,OAMpB+D,YAAc1C,UAAY,EAAI,EAIxB2C,MAAQ5D,iBAxLN,GAwLsCgD,aAC9CxD,KAAKqE,OAAS,CACVC,EAAG,EACH5D,EAAG0D,MAAM1D,EACTE,EAAGwD,MAAMxD,EACTH,MAVS,OAUWgC,iBAAiB0B,kBAQrCI,WAAanC,OAAOI,SACpBgC,MAAQD,WAAWzE,OAAS,EAChCE,KAAKyE,OAAS,IAAIvE,MAAMsE,WACnB,IAAI1B,IAAI,EAAGA,IAAI0B,QAAS1B,IACzB9C,KAAKyE,OAAO3B,KAAK,CACb4B,MAAOH,WAAWzB,IAAI,GACtB6B,cAAe7B,IAAI,UAKxB8B,mBAAUC,OAAO,sBAAuB7E,MAC9CkC,MAAK,SAAA4C,UACIC,UAAYC,SAASC,eAAe,SAC1CF,UAAUG,UAAYJ,SAEhBK,MAAQJ,UAAUK,cAAc,WAClCC,gBAAe,eAETC,KAAOH,MAAMI,wBAEfC,OAAS,EACTF,KAAKG,MAAQ,IACbD,OAAS,GACFF,KAAKG,MAAQ,IACpBD,OAAS,GACFF,KAAKG,MAAQ,MACpBD,OAAS,IAGbL,MAAMO,MAAMC,SAAW/F,QAAQE,OAASwF,KAAKvF,OAASyF,OAAS,SAChEI,QAAQb,eAGPV,OAASU,UAAUK,cAAc,gBACjCS,YAAcd,UAAUe,iBAAiB,cACzCzF,SAAW0E,UAAUe,iBAAiB,mBAC1Cd,SAASC,eAAe,gBAAgBc,iBAAiB,UAAU,SAACC,WAC1DrB,cAAgBqB,MAAMC,OAAOC,QAAQC,cAE3C/D,OAAOM,wBAAwBiC,eAC/BjD,IAAI,SAAU,KAAMU,OAAOI,SAASmC,oBAE/B,IAAI7B,IAAI,EAAGA,IAAI,IAAKA,IAAG,KAEpBsD,WAAaP,YAAY/C,KACzBuD,SAAUrG,KAAKC,KAAK6C,KACpB1B,SAAWgB,OAAOK,iBAAiBK,KACnChD,OAASuG,SAAQ3C,KAAKrC,YAAc,EAAID,UAC5CgF,WAAWE,aAAa,oBAAqBxG,QAC7CO,SAAS,EAAIyC,KAAGoC,UAAY1F,KAAKuE,MAAiB,IAAX3C,cAErCmF,YAtEG,OAsEwBnE,OAAOK,iBAAiB0B,aACzDE,OAAOiC,aAAa,YAAa,UAAYC,YAAc,cAMtEC,OAAM,SAAAC,YAAOC,OAAOC,QAAQC,MAAMH"}